---
title: 设计模式之工厂方法模式
copyright: true
mathjax: true
date: 2020-12-25 15:11:25
categories:
- 笔记
- 设计模式
- 创建型设计模式
tags:
- 设计模式
---



![工厂方法模式](https://gitee.com/junpzx/blog-img/raw/master//img/20201225151240.png)

<!-- less -->

# 设计模式之工厂方法模式

# 💬意图

**工厂方法模式**是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

![工厂方法模式](https://gitee.com/junpzx/blog-img/raw/master//img/20201225151240.png)



# ☹️问题

假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 `卡车`的类中。

一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。

![如果代码其余部分与现有类已经存在耦合关系， 那么向程序中添加新类其实并没有那么容易](https://gitee.com/junpzx/blog-img/raw/master//img/20201225152431.png)

这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与 `卡车`类相关。 在程序中添加 `轮船`类需要修改全部代码。 更糟糕的是， 如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。

最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。



# 😃解决方案

工厂方法模式建议使用特殊的*工厂*方法代替对于对象构造函数的直接调用 （即使用 `new`运算符）。 不用担心， 对象仍将通过 `new`运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。

![子类可以修改工厂方法返回的对象类型](https://gitee.com/junpzx/blog-img/raw/master//img/20201225152710.png)



乍看之下， 这种更改可能毫无意义： 我们只是改变了程序中调用构造函数的位置而已。 但是， 仔细想一下， 现在你可以在子类中重写工厂方法， 从而改变其创建产品的类型。

但有一点需要注意:仅当这些产品具有共同的基类或者接口时， 子类才能返回不同类型的产品， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。

![所有产品都必须使用同一接口](https://gitee.com/junpzx/blog-img/raw/master//img/20201225152825.png)

举例来说，  `卡车`Truck和 `轮船`Ship类都必须实现 `运输`Transport接口， 该接口声明了一个名为 `deliver`交付的方法。 每个类都将以不同的方式实现该方法： 卡车走陆路交付货物， 轮船走海路交付货物。  `陆路运输`Road­Logistics类中的工厂方法返回卡车对象， 而 `海路运输`Sea­Logistics类则返回轮船对象。

![只要产品类实现一个共同的接口， 你就可以将其对象传递给客户代码， 而无需提供额外数据](E:%5CDesktop%5Csolution3-zh.png)

调用工厂方法的代码 （通常被称为*客户端*代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的 `运输` 。 客户端知道所有运输对象都提供 `交付`方法， 但是并不关心其具体实现方式。



# 🤔 工厂方法模式结构

![工厂方法模式结构](https://gitee.com/junpzx/blog-img/raw/master//img/20201225152939.png)



1. **产品** （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。

2. **具体产品** （Concrete Products） 是产品接口的不同实现。

3. **创建者** （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。

    你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。

    注意， 尽管它的名字是创建者， 但他最主要的职责并**不是**创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。

4. **具体创建者** （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。

    注意， 并不一定每次调用工厂方法都会**创建**新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。



# 💡工厂方法模式适合应用场景

🧨当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。

🏮工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分  	 代码。

​	 例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。

🧨如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。

🏮继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时， 框架如何辨识出该	 子类？

​	 解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行	 重写。

​	 让我们看看具体是如何实现的。 假设你使用开源 UI 框架编写自己的应用。 你希望在应用中使用圆形按钮， 但	 是原框架仅支持矩形按钮。 你可以使用 `圆形按钮`Round­Button子类来继承标准的 `按钮`Button类。 但是， 你	 需要告诉 `UI框架`UIFramework类使用新的子类按钮代替默认按钮。

​	 为了实现这个功能， 你可以根据基础框架类开发子类 `圆形按钮 UI`UIWith­Round­Buttons ， 并且重写其 	 	  	 `create­Button`创建按钮方法。 基类中的该方法返回 `按钮`对象， 而你开发的子类返回 `圆形按钮`对象。 现在， 	 你就可以使用 `圆形按钮 UI`类代替 `UI框架`类。 就是这么简单！

🧨如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。

🏮在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。

​	 让我们思考复用现有对象的方法：

​		1.首先， 你需要创建存储空间来存放所有已经创建的对象。

​		2.当他人请求一个对象时， 程序将在对象池中搜索可用对象。

​		3.…然后将其返回给客户端代码。

​		4.如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。

​	 这些代码可不少！ 而且它们必须位于同一处， 这样才能确保重复代码不会污染程序。

​	 可能最显而易见， 也是最方便的方式， 就是将这些代码放置在我们试图重用的对象类的构造函数中。 但是从	 定义上来讲， 构造函数始终返回的是**新对象**， 其无法返回现有实例。

​	 因此， 你需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去和工厂方法非常相像。

