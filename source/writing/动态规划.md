---
title: 动态规划
date: 2020-11-27 14:34:55
mathjax: true
categories:
- 笔记
- 算法
tags:
- Java
copyright: true
---

> ​		**动态规划（英语：Dynamic programming，简称DP）**是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
>
> ​		**动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。**
>
> ​		动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。
>
> ​		通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

以上内容摘抄至[维基百科](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)

<!-- less -->



## 前言

​		**动态规划问题的一般形式就是求最值**。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求**最长**递增子序列呀，**最小**编辑距离呀等等。

​		既然是要求最值，核心问题是什么呢？**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。

​		动态规划就这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！

​		首先，动态规划的穷举有点特别，因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

​		而且，动态规划问题一定会**具备「最优子结构」**，才能通过子问题的最值得到原问题的最值。

​		另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出**正确的「状态转移方程」**才能正确地穷举。

​		以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，**写出状态转移方程是最困难的**，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：

$$明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。$$



## 案例

### 案例一：斐波那契数列

#### 1.暴力递归

斐波那契数列的数学形式就是递归的，写成代码就是这样：

```java
public static int fib(int n) {
    if (n == 1 || n == 2) { 
        return 1;
    }
    return fib(n - 1) + fib(n - 2);
}
```

我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树。

![斐波那契数列图](https://gitee.com/junpzx/blog-img/raw/master//img/20201127155942.jpg)

​		这个递归树怎么理解？就是说想要计算原问题$$f(20)$$，我就得先计算出子问题$$f(19)$$和$$f(18)$$，然后要计算$$f(19)$$，我就要先算出子问题$$f(18)$$和$$f(17)$$，以此类推。最后遇到$$f(1)$$或者$$f(2)$$的时候，结果已知，就能直接返回结果，递归树不再向下生长了。

​		**递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间。**

​		子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 $$O(2^n)$$

​		解决一个子问题的时间，在本算法中，没有循环，只有 $$f(n - 1) + f(n - 2)$$ 一个加法操作，时间为 $$O(1)$$。所以，这个算法的时间复杂度为 $$O(2^n)$$，指数级别，爆炸。

​		观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如`f(18)`被计算了两次，而且你可以看到，以`f(18)`为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止`f(18)`这一个节点被重复计算，所以这个算法及其低效。

​		这就是动态规划问题的第一个性质：**重叠子问题**。下面，我们想办法解决这个问题。



#### 2.带备忘录的递归解法

​		明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。

​		一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。

```java
 public static int fib2(int n) {
    Map<Integer, Integer> memo = new HashMap<Integer, Integer>(n);
    return helper(memo, n);
}

public static int helper(Map<Integer, Integer> memo, int n) {
    if (n == 1 || n == 2) {
        return 1;
    }
    // 已经计算过
    if (memo.containsKey(n)) {
        return memo.get(n);
    }
    memo.put(n, helper(memo, n - 1) + helper(memo, n - 2));
    return memo.get(n);
}
```

​		实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题的个数。

​		**递归算法的时间复杂度怎么算？** **子问题个数乘以解决一个子问题需要的时间。**

​		子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是$$f(1),f(2),f(3)…f(20)$$，数量和输入规模 n = 20 成正比，所以子问题个数为 $$O(n)$$。

​		解决一个子问题的时间，同上，没有什么循环，时间为$$O(1)$$。

​		所以，本算法的时间复杂度是 $$O(n)$$。比起暴力算法，是降维打击。

​		至此，带备忘录的递归解法的效率已经和迭代的动态规划一样了。实际上，这种解法和迭代的动态规划思想已经差不多，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。

​		**啥叫「自顶向下」？**注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说$$f(20)$$，向下逐渐分解规模，直到$$f(1)$$和$$f(2)$$触底，然后逐层返回答案，这就叫「自顶向下」。

​		**啥叫「自底向上」？**反过来，我们直接从最底下，最简单，问题规模最小的$$f(1)$$和$$f(2)$$开始往上推，直到推到我们想要的答案$$f(20)$$，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

​	

#### 3.dp 数组的迭代解法



